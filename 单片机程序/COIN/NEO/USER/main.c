#include "sys.h"
#include "delay.h"
#include <string.h>
#include <stdio.h>	 
#include "encrypt.h"
#include "showsign.h"
#include "getaddress.h" 
#include "stmflash.h"

//#define Debug
#define FLASH_NEO_ADDRESS					0x08060000
#define FLASH_NEODUN_ADDRESS			0x08020000
#define FLASH_PACK_ADDRESS				0x08010000
#define FLASH_RESULT_sign_ADDRESS	0x0800F000
#define FLASH_RESULT_alg_ADDRESS	0x0800F800

#ifdef Debug
		uint8_t privateKey_flash[32] = 
		{
				0x35,0x67,0x3e,0xcf,0x9f,0x18,0xf4,0x4e,0xbd,0x1c,0x9f,0xc7,0xca,0xc4,0x32,0x7d,
				0x72,0xee,0xb0,0x81,0x04,0xef,0xfd,0x20,0xfb,0xbb,0x62,0x13,0x41,0xb8,0x0a,0xc1
		};
		uint32_t pack_len = 193;
		uint8_t data_pack[] =
		{
				0x80,0x00,0x00,0x02,0x56,0xe9,0x0e,0x3c,0x0c,0x4d,0x34,0x75,0x9c,0xa7,0x9a,0x82,0x44,0xec,0x59,0x85,
				0xb3,0xb0,0x1e,0x6e,0x11,0xd4,0xe5,0xa5,0x6f,0xc9,0x13,0x6a,0x3a,0xc1,0xeb,0x8b,0x00,0x00,0xa3,0xab,
				0xfe,0xc4,0x7f,0xf7,0x15,0xb6,0x02,0x95,0xa6,0xc7,0x09,0x5e,0xbf,0x8c,0xb8,0x45,0x3f,0xc3,0x9b,0x2c,
				0x6c,0x11,0x6c,0x12,0xba,0xa0,0xb9,0xdc,0xc3,0xf7,0x01,0x00,0x02,0x9b,0x7c,0xff,0xda,0xa6,0x74,0xbe,
				0xae,0x0f,0x93,0x0e,0xbe,0x60,0x85,0xaf,0x90,0x93,0xe5,0xfe,0x56,0xb3,0x4a,0x5c,0x22,0x0c,0xcd,0xcf,
				0x6e,0xfc,0x33,0x6f,0xc5,0x00,0xc2,0xeb,0x0b,0x00,0x00,0x00,0x00,0x35,0xb2,0x00,0x10,0xdb,0x73,0xbf,
				0x86,0x37,0x10,0x75,0xdd,0xfb,0xa4,0xe6,0x59,0x6f,0x1f,0xf3,0x5d,0x9b,0x7c,0xff,0xda,0xa6,0x74,0xbe,
				0xae,0x0f,0x93,0x0e,0xbe,0x60,0x85,0xaf,0x90,0x93,0xe5,0xfe,0x56,0xb3,0x4a,0x5c,0x22,0x0c,0xcd,0xcf,
				0x6e,0xfc,0x33,0x6f,0xc5,0x00,0x21,0x6e,0x83,0x01,0x00,0x00,0x00,0x35,0xb2,0x00,0x10,0xdb,0x73,0xbf,
				0x86,0x37,0x10,0x75,0xdd,0xfb,0xa4,0xe6,0x59,0x6f,0x1f,0xf3,0x5d
		};
#else
		uint8_t privateKey_flash[32];
		uint8_t data_pack[512];
		uint32_t pack_len = 0;
#endif

typedef  void (*iapfun)(void);
iapfun jump2app;
//跳转到指定应用程序段
//appxaddr:用户代码起始地址.
void jump_to_app(uint32_t appxaddr)
{	
		if(((*(vu32*)appxaddr)&0x2FFE0000)==0x20000000)	//检查栈顶地址是否合法.
		{ 
				jump2app=(iapfun)*(vu32*)(appxaddr+4);		//用户代码区第二个字为程序开始地址(复位地址)		
				MSR_MSP(*(vu32*)appxaddr);								//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)
				jump2app();																//跳转到APP.
		}
} 

int main(void)
{
#ifndef Debug
		SCB->VTOR = FLASH_BASE | 0x60000;//设置偏移量
#endif	
		uint8_t resultsignRecord[98];
		int 		len_sign_alg = 0;
		uint8_t result_SignData[64];
		SIGN_Out_Para Sign;
		uint8_t hash_all[32];
		int	hash_len = 0;
		uint8_t PublicKey_Flash[65];
		uint8_t PubKey_Flash[33];
	
		//硬件初始化
		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置系统中断优先级分组2
		delay_init(168);		  	 //初始化延时函数
		RNG_DeInit();
		CRC_ResetDR();

		//数据初始化
#ifndef Debug	
		memset(&data_pack,0,512);
		pack_len = STMFLASH_ReadWord(FLASH_PACK_ADDRESS);
		STMFLASH_Read(FLASH_PACK_ADDRESS+4,(uint32_t*)privateKey_flash,32);
		STMFLASH_Read(FLASH_PACK_ADDRESS+36,(uint32_t*)data_pack,pack_len);
#endif
		memset(&Sign,0,sizeof(Sign));
		memset(&result_SignData,0,64);
		memset(&resultsignRecord,0,98);
		
		//解析数据包
		if(Alg_ShowSignData(data_pack,pack_len,&Sign))
		{
				STMFLASH_WriteWord(FLASH_RESULT_sign_ADDRESS,0);
				return 0;
		}
		//签名数据包
		if(Alg_ECDSASignData(data_pack,pack_len,result_SignData,&len_sign_alg,privateKey_flash))
		{		
				STMFLASH_WriteWord(FLASH_RESULT_sign_ADDRESS,0);
				return 0;
		}
		
		//组合最终的数据
		Alg_GetPublicFromPrivate(privateKey_flash,PublicKey_Flash,1);
		memmove(PubKey_Flash,PublicKey_Flash,33);
		resultsignRecord[0] = 33;
		memmove(resultsignRecord+1,PubKey_Flash,33);
		memmove(resultsignRecord+34,result_SignData,64);
		Alg_HashData(resultsignRecord, 98, hash_all, &hash_len);
		
		//将结果写入FLASH
		STMFLASH_Write(FLASH_RESULT_sign_ADDRESS+4,(uint32_t*)&Sign,sizeof(Sign));//记录解释签名结果
		STMFLASH_Write(FLASH_RESULT_alg_ADDRESS,(uint32_t*)resultsignRecord,98);	//记录签名数据结果
		
		//回跳到NEODUN
		jump_to_app(FLASH_NEODUN_ADDRESS);//跳回大厅APP
}

	

 
/*****************************************End of file*******************************************/


